
## CAPÍTULO 12: CIENCIAS DE LA COMPUTACIÓN

Este capítulo incluye problemas relacionados con temas fundamentales de la ciencia de la computación, como estructuras de datos, algoritmos, complejidad computacional y técnicas de programación. Estos problemas están diseñados para ayudar a los estudiantes a desarrollar habilidades en el diseño y análisis de algoritmos y en la implementación de soluciones de programación.

1. Implementar un algoritmo de búsqueda lineal para encontrar un elemento en una lista.
2. Implementar un algoritmo de búsqueda binaria para encontrar un elemento en una lista ordenada.
3. Escribir un programa que ordene una lista de números utilizando el algoritmo de ordenamiento por burbuja.
4. Escribir un programa que ordene una lista de números utilizando el algoritmo de ordenamiento por inserción.
5. Escribir un programa que ordene una lista de números utilizando el algoritmo de ordenamiento por selección.
6. Implementar el algoritmo de ordenamiento rápido (quicksort) para ordenar una lista de números.
7. Implementar el algoritmo de ordenamiento por fusión (mergesort) para ordenar una lista de números.
8. Escribir un programa que implemente el algoritmo de ordenamiento de montículos (heapsort).
9. Implementar un algoritmo para encontrar el máximo común divisor (MCD) de dos números utilizando el método de Euclides.
10. Implementar un algoritmo para encontrar el mínimo común múltiplo (MCM) de dos números.
11. Escribir un programa que implemente el algoritmo de búsqueda en profundidad (DFS) en un grafo.
12. Escribir un programa que implemente el algoritmo de búsqueda en anchura (BFS) en un grafo.
13. Implementar un algoritmo para encontrar el camino más corto entre dos nodos en un grafo utilizando el algoritmo de Dijkstra.
14. Implementar un algoritmo para encontrar el árbol de expansión mínima en un grafo utilizando el algoritmo de Kruskal.
15. Implementar un algoritmo para encontrar el árbol de expansión mínima en un grafo utilizando el algoritmo de Prim.
16. Escribir un programa que implemente el algoritmo de Floyd-Warshall para encontrar todos los caminos más cortos en un grafo.
17. Implementar un algoritmo para detectar ciclos en un grafo dirigido.
18. Implementar un algoritmo para detectar ciclos en un grafo no dirigido.
19. Escribir un programa que implemente el algoritmo de ordenación topológica en un grafo dirigido acíclico (DAG).
20. Implementar un algoritmo de búsqueda de patrones en una cadena utilizando el algoritmo de Knuth-Morris-Pratt (KMP).
21. Implementar un algoritmo de búsqueda de patrones en una cadena utilizando el algoritmo de Boyer-Moore.
22. Escribir un programa que implemente el algoritmo de compresión de datos Huffman.
23. Implementar un algoritmo para la búsqueda de cadenas utilizando la técnica de hash de Rabin-Karp.
24. Implementar un algoritmo de búsqueda de subcadenas utilizando el algoritmo de Aho-Corasick.
25. Escribir un programa que implemente el algoritmo de Floyd para encontrar el ciclo más corto en un grafo ponderado.
26. Implementar un algoritmo de planificación de tareas utilizando el algoritmo de Johnson.
27. Escribir un programa para implementar una cola de prioridad utilizando un montículo binario.
28. Implementar una tabla hash con manejo de colisiones mediante encadenamiento.
29. Implementar una tabla hash con manejo de colisiones mediante direccionamiento abierto.
30. Escribir un programa para implementar un árbol binario de búsqueda (BST).
31. Implementar un algoritmo para equilibrar un árbol binario de búsqueda utilizando rotaciones AVL.
32. Implementar un árbol rojo-negro (Red-Black Tree).
33. Escribir un programa para implementar un trie para almacenar y buscar cadenas.
34. Implementar un algoritmo de ordenación externa utilizando el algoritmo de fusión de varios caminos.
35. Escribir un programa para implementar un grafo utilizando listas de adyacencia.
36. Implementar un grafo utilizando matrices de adyacencia.
37. Escribir un programa que implemente el algoritmo de multiplicación de matrices de Strassen.
38. Implementar un algoritmo para calcular la transformada rápida de Fourier (FFT).
39. Escribir un programa para calcular la transformada inversa de Fourier.
40. Implementar un algoritmo de cifrado y descifrado utilizando el cifrado de César.
41. Implementar un algoritmo de cifrado y descifrado utilizando el cifrado de Vigenère.
42. Escribir un programa para implementar el algoritmo de encriptación RSA.
43. Implementar un algoritmo de generación de números pseudoaleatorios utilizando el método de congruencia lineal.
44. Implementar un algoritmo de generación de números pseudoaleatorios utilizando el método de LFSR (Linear Feedback Shift Register).
45. Escribir un programa para calcular el número de permutaciones posibles de una lista de elementos.
46. Implementar un algoritmo para calcular el número de combinaciones posibles de elegir \(k\) elementos de un conjunto de \(n\) elementos.
47. Implementar un algoritmo de recorrido en orden preorden, enorden y postorden en un árbol binario.
48. Escribir un programa para convertir un árbol binario a su representación de árbol de búsqueda binaria (BST).
49. Implementar un algoritmo para encontrar el ancestro común más cercano de dos nodos en un árbol binario.
50. Escribir un programa que implemente un autómata finito determinista (DFA).
51. Implementar un autómata finito no determinista (NFA).
52. Escribir un programa que implemente la conversión de un NFA a un DFA.
53. Implementar un algoritmo para simular una máquina de Turing.
54. Escribir un programa para evaluar una expresión aritmética utilizando la notación polaca inversa (RPN).
55. Implementar un algoritmo para la evaluación de expresiones aritméticas utilizando un árbol de expresión.
56. Escribir un programa para implementar un analizador léxico para una expresión matemática.
57. Implementar un algoritmo de generación de código para una máquina hipotética utilizando un compilador simple.
58. Escribir un programa para implementar una máquina de pila (stack machine).
59. Implementar un algoritmo de evaluación de expresiones booleanas utilizando un árbol de expresión.
60. Escribir un programa que implemente una máquina de estados finitos para un juego simple.
61. Implementar un algoritmo de procesamiento de lenguaje natural para tokenizar una cadena de texto.
62. Escribir un programa que implemente el algoritmo de Levenshtein para calcular la distancia de edición entre dos cadenas.
63. Implementar un algoritmo para la búsqueda de aproximación de cadenas utilizando el algoritmo de Levenshtein.
64. Escribir un programa para calcular la complejidad de tiempo de un algoritmo dado utilizando la notación Big-O.
65. Implementar un algoritmo para calcular la complejidad de espacio de un algoritmo utilizando la notación Big-O.
66. Escribir un programa que implemente un sistema de gestión de memoria utilizando el algoritmo de paginación.
67. Implementar un sistema de gestión de memoria utilizando el algoritmo de segmentación.
68. Escribir un programa para simular un algoritmo de planificación de procesos utilizando Round-Robin.
69. Implementar un algoritmo de planificación de procesos utilizando el algoritmo de prioridad.
70. Escribir un programa para simular un sistema operativo simple con manejo de procesos y memoria.
71. Implementar un sistema de archivos simple con operaciones de creación, lectura, escritura y eliminación.
72. Escribir un programa para implementar un intérprete simple de un lenguaje de programación.
73. Implementar un algoritmo de optimización de compiladores utilizando el análisis de flujo de datos.
74. Escribir un programa que implemente un sistema de detección de intrusiones en una red utilizando un algoritmo de aprendizaje automático.
75. Implementar un algoritmo de reconocimiento de patrones utilizando una red neuronal básica.
76. Escribir un programa para implementar un sistema de recomendación utilizando filtrado colaborativo.
77. Implementar un algoritmo de agrupamiento utilizando el algoritmo K-means.
78. Escribir un programa que implemente un árbol de decisión para la clasificación de datos.
79. Implementar un algoritmo de búsqueda de profundidad limitada (IDS).
80. Escribir un programa para simular un juego de ajedrez utilizando inteligencia artificial.
